Chapter 4 - Multithreaded Programming

4.1 Overview
 Basic unit of cpu utilization: comprises thread id, pc, register set, stack. Shares code sections, data section, resources(open files, signals) with other threads.

    4.1.1 Motivation
     Can do multiple tasks at once

    4.1.2 Benefits
     Thread creation is light-weight. Responsivenes; Resourrce sharing; Economy; Utilization of multiprocess architectures

4.2 Multithreading Models
    4.2.1 Many-to-One Model
     Disadvantages: Entire process blocks if a thread makes a blocking system call; unable to in parallel on multiprocessors

    4.2.2 One-to-One Model
     Disadvantages: Bacuse the overhead of creating kernel threads can burden the performance of the application, most applications restrict the no of threads.

    4.2.3 Many-to-Many Model
     None of the above shortcomings are there in this model

(Threads ar evil: threads not as libraries)

4.3 Thread Libraries
 user-level and kernel-level thread libraries
 rest is not covered in the class:
    4.3.1 Pthreads
    4.3.2 Win32 Threads
    4.3.3 Java Threads

4.4 Theading Issues
    4.4.1 The fork() and exec() System Calls
     Should fork() duplicate all the threads(not useful when we use an exec()), or should it only duplicate the current threads(useful when we are to use exec())
     Linux implements both these implementations

    4.4.2 Cancellation
     Terminating a thread before it has completed: Asynchronous Cancellation(disadvantages: cancellation in midst of updating resources), 
     Deferred Cancellation(target thread periodically checks if the flag for it to be terminated is set, when it is set it terminates itself in an orderly fashion)

    4.4.3 Signal Handling
     3 parts: Signal is generated by occurence of an event; signal is delivered to the process; once delivered signal must be handled. Part 1 is trivial
     Part 2: These possibilties: deliver signal to the thread to which it applies(synchronous signals), delivered to every thread of the process, deliver to 
     certain thread of the process(some threads may block some signals)(asynchronous signals), assign a thread to receive the signals
     part 3: Default signal handler or user-defined signal handler

    4.4.4 Thread Pools
     After process start, many threads are created and are kept in a pool. 2 advantages: serviceing requests with existing pools is faster, limits number of threads

    4.4.5 Thread-Specific Data
     Threads of a same process share data, but we can assign thread-specific data when required.

    4.4.6 Scheduler Activations
     No communication between user-level and kernel-level threads: def - LWP(Light weight process- a virtual processor to the user-level thread to run on), each LWP 
     is connected to a kernel thread. Problem: if a kernel level thread blocks then the LWP and hence the processor running on it will also block.
     Solution: Scheduler Activation: Kernel provides application with LWPs and application can schedule on it. Kernel can in form an application about certain 
     events by issuing upcalls. These are handled by upcall-handlers(run on a virtual processor). Ex. kernel makes an upcall to an application when it is about to
     block. The kernel then allocates a new virtual processor to the application. The application runs the upcall-handler on this new virtual processor. The upcall 
     handler saves the state of the blocking thread and relInquishes the associated virtual processor. The upcall-handler then scxhedules another thread that is 
     eligible to run on the new virtual processor. Similarly when the blocking thread is now eligible to run, kernel makes another upcall and maybe allocates a new 
     vitual processor and the upcall handler runs on this virtual processor.
     
Rest of the topics were not covered in the class.
4.5 Operating Systems Examples
    4.5.1 Windows XP Threads
    4.5.2 Linux Threads

4.6 Summary